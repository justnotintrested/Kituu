<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Us</title>
<script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
<style>
body{
  margin:0; height:100vh; overflow:hidden;
  display:flex; flex-direction:column;
  justify-content:center; align-items:center;
  background:radial-gradient(circle at top, #1b1b2f, #0e0e11);
  color:#fff; font-family:system-ui;
}
.bg{
  position:absolute; inset:0;
  background:
    radial-gradient(#ffffff22 1px, transparent 1px);
  background-size:60px 60px;
  animation:float 40s linear infinite;
  opacity:.25;
}
@keyframes float{
  from{background-position:0 0;}
  to{background-position:1000px 1000px;}
}
.heart{
  width:120px; height:120px;
  background:#ff4d6d;
  position:relative;
  transform:rotate(-45deg);
  animation:beat 2s infinite;
  cursor:pointer;
  box-shadow:0 0 40px #ff4d6d88;
  z-index:2;
}
.heart.filth{
  background:#cc0000;
  box-shadow:0 0 40px #cc000088;
  animation:beat 1s infinite; /* Faster beat for filth mode */
}
.heart.filth::before, .heart.filth::after{
  background:#cc0000;
}
.heart::before,.heart::after{
  content:"";
  width:120px;height:120px;
  background:#ff4d6d;
  border-radius:50%;
  position:absolute;
}
.heart::before{ top:-60px; left:0;}
.heart::after{ left:60px; top:0;}
@keyframes beat{
  0%,100%{ transform:scale(1) rotate(-45deg);}
  50%{ transform:scale(1.15) rotate(-45deg);}
}
p{ margin-top:30px; opacity:.85; text-align:center; z-index:2;}
.msg{ margin-top:15px; font-size:14px; opacity:.9; z-index:2;}
.msg span { animation: drip 1s infinite; display: inline-block; }
@keyframes drip { 0% { transform: translateY(0); } 50% { transform: translateY(5px); } }
#particles-js { position:absolute; inset:0; z-index:1; }
#addMessageContainer { margin-top: 20px; z-index: 2; }
#addMessageContainer input { padding: 8px; width: 200px; border: none; border-radius: 4px; }
#addMessageContainer button { padding: 8px 12px; margin-left: 10px; background: #ff4d6d; color: white; border: none; border-radius: 4px; cursor: pointer; }
#addMessageContainer button:hover { background: #e6395e; }
</style>
</head>
<body>
<div id="particles-js"></div>
<div class="bg"></div>
<div class="heart"></div>
<p>This beats because of us.<br>Waiting for 2027.</p>
<div class="msg" id="msg">Tap the heart ‚ù§Ô∏è</div>
<audio id="heartSound" src="https://example.com/heartbeat.mp3"></audio>
<audio id="filthSound" src="https://example.com/fast-heartbeat.mp3"></audio>
<div id="addMessageContainer">
  <input type="text" id="newMsgInput" placeholder="Add a new message...">
  <button onclick="addMessage()">Add</button>
</div>
<script>
let romanticMessages = [
  "Still choosing you. ‚ù§Ô∏è",
  "Distance didn‚Äôt stop this. üåç",
  "We‚Äôre building, slowly. üõ†Ô∏è",
  "One day closer, always. ‚è≥",
  "This heart knows the wait. üíï"
];

let filthMessages = [
  "Craving your wet touch <span>üí¶</span>.",
  "Imagining you dripping for me <span>üí¶</span>.",
  "Can't wait to make you moan üî•.",
  "This throbs, hard and ready <span>üçÜ</span>.",
  "Let's get filthy and soaked <span>üí¶</span>."
];

let i = 0;
let isFilth = false;
let pressTimer;
let isLongPress = false;

const owner = 'justnotintrested';
const repo = 'Kituu';
const token = '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'; 
const romanticPath = 'romantic.txt';
const filthPath = 'filth.txt';

const heart = document.querySelector('.heart');
const pElement = document.querySelector('p');
const msgElement = document.getElementById('msg');
const heartSound = document.getElementById('heartSound');
const filthSound = document.getElementById('filthSound');

// Base64 SVGs for particles
const heartImage = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cGF0aCBkPSJNMjMuNiAyYy0zLjQgMC02LjQgMi4xLTcuNiA1LjFDMTQuOCA0LjEgMTEuOCAyIDguNCAyIDMuOCAyIDAgNS44IDAgMTAuNGMwIDUuNCA0LjUgOS44IDExLjMgMTYuMmw0LjcgNC40IDQuNy00LjRDMjcuNSAyMC4yIDMyIDE1LjggMzIgMTAuNCAzMiA1LjggMjguMiAyIDIzLjYgMnoiIGZpbGw9IiNmZjRkNmQiLz4KPC9zdmc+';
const dropImage = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cGF0aCBkPSJNMTYgMkMxMS42IDIgOCA1LjYgOCAxMGMwIDMuMyAyLjcgNiA2IDZoNGMzLjMgMCA2LTIuNyA2LTYgMC00LjQtMy42LTggOC04em0wIDI4Yy00LjQgMC04LTMuNi04LThjMC0xLjguNi0zLjQgMS42LTQuN0wxNiAyNGw2LjQtNi43QzIzLjQgMTYuNiAyNCAxNSAyNCAxMy4yYzAtNC40LTMuNi04LTgtOHMtOCAzLjYtOCA4YzAgMS44LjYgMy40IDEuNiA0LjdMMTYgMjRsNi40LTYuN0MyMy40IDE4LjYgMjQgMjAuMiAyNCAyMmMwIDQuNC0zLjYgOC04IDh6IiBmaWxsPSIjY2MwMDAwIi8+Cjwvc3ZnPg==';

// Shareable link param
const urlParams = new URLSearchParams(window.location.search);
if (urlParams.get('mode') === 'filth') {
  isFilth = true;
  updateVisuals();
  i = 0;
  nextMsg();
}

function nextMsg() {
  const msgs = isFilth ? filthMessages : romanticMessages;
  msgElement.innerHTML = msgs[i++ % msgs.length]; // Use innerHTML for spans
  if (isFilth) {
    filthSound.play();
  } else {
    heartSound.play();
  }
}

function toggleFilth() {
  isFilth = !isFilth;
  updateVisuals();
  initParticles();
  i = 0;
  nextMsg();
}

function updateVisuals() {
  if (isFilth) {
    heart.classList.add('filth');
    pElement.innerHTML = "This throbs for us.<br>Craving wet 2027.";
    msgElement.innerText = "Press for heat üî•";
  } else {
    heart.classList.remove('filth');
    pElement.innerHTML = "This beats because of us.<br>Waiting for 2027.";
    msgElement.innerText = "Tap the heart ‚ù§Ô∏è";
  }
}

function initParticles() {
  const particleShape = {
    type: 'image',
    image: {
      src: isFilth ? dropImage : heartImage,
      width: 32,
      height: 32
    }
  };

  particlesJS('particles-js', {
    particles: {
      number: { value: 50 },
      color: { value: '#ffffff' }, // White to not override image color
      shape: particleShape,
      opacity: { value: 0.5 },
      size: { value: 5 },
      move: { enable: true, speed: 3 }
    },
    interactivity: { events: { onhover: { enable: false } } }
  });
}

// Load messages from GitHub on start
function loadMessages(isFilthMode) {
  const path = isFilthMode ? filthPath : romanticPath;
  fetch(`https://raw.githubusercontent.com/${owner}/${repo}/main/${path}`)
    .then(res => {
      if (res.ok) return res.text();
      throw new Error('Not found');
    })
    .then(text => {
      const msgs = text.split('\n').filter(m => m.trim());
      if (isFilthMode) filthMessages = msgs;
      else romanticMessages = msgs;
    })
    .catch(() => console.log(`No ${path} file, using defaults`));
}
loadMessages(false);
loadMessages(true);

// Add new message
function addMessage() {
  const newMsg = document.getElementById('newMsgInput').value.trim();
  if (newMsg) {
    const msgs = isFilth ? filthMessages : romanticMessages;
    msgs.push(newMsg);
    document.getElementById('newMsgInput').value = '';
    updateGitHubFile();
  }
}

async function getFileSHA(path) {
  try {
    const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    });
    if (res.ok) {
      const data = await res.json();
      return data.sha;
    }
    return null;
  } catch (e) {
    return null;
  }
}

async function updateGitHubFile() {
  const path = isFilth ? filthPath : romanticPath;
  const msgs = isFilth ? filthMessages : romanticMessages;
  const content = btoa(msgs.join('\n') + '\n'); // Add trailing newline
  const sha = await getFileSHA(path);

  const body = {
    message: 'Add new message',
    content: content
  };
  if (sha) body.sha = sha;

  fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
    method: 'PUT',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Accept': 'application/vnd.github.v3+json',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body)
  }).then(res => {
    if (res.ok) console.log('File updated/created on GitHub');
    else console.error('Error updating file');
  }).catch(err => console.error(err));
}

// Mouse events
heart.addEventListener('mousedown', () => {
  isLongPress = false;
  pressTimer = setTimeout(() => {
    isLongPress = true;
    toggleFilth();
  }, 1000);
});

heart.addEventListener('mouseup', () => {
  clearTimeout(pressTimer);
  if (!isLongPress) {
    nextMsg();
  }
});

heart.addEventListener('mouseleave', () => {
  clearTimeout(pressTimer);
});

// Touch events
heart.addEventListener('touchstart', () => {
  isLongPress = false;
  pressTimer = setTimeout(() => {
    isLongPress = true;
    toggleFilth();
  }, 1000);
}, {passive: true});

heart.addEventListener('touchend', () => {
  clearTimeout(pressTimer);
  if (!isLongPress) {
    nextMsg();
  }
});

// Countdown Timer
const targetDate = new Date('2027-01-01T00:00:00');
const countdownElement = document.createElement('div');
countdownElement.id = 'countdown';
countdownElement.style.marginTop = '20px';
countdownElement.style.fontSize = '16px';
countdownElement.style.opacity = '0.85';
countdownElement.style.zIndex = '2';
document.body.insertBefore(countdownElement, document.getElementById('addMessageContainer'));

function updateCountdown() {
  const now = new Date();
  const diff = targetDate - now;
  if (diff > 0) {
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((diff % (1000 * 60)) / 1000);
    countdownElement.innerText = `${days}d ${hours}h ${minutes}m ${seconds}s until us.`;
  } else {
    countdownElement.innerText = "The wait is over! üéâ";
  }
}
setInterval(updateCountdown, 1000);
updateCountdown();

// Initialize particles on load
initParticles();
</script>
</body>
</html>
